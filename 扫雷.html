<!DOCTYPE html>
<html lang="zh-CN">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>æ‰«é›·æ¸¸æˆ</title>
	<style>
		body {
			font-family: Arial, sans-serif;
			display: flex;
			flex-direction: column;
			align-items: center;
			background-color: #f0f0f0;
			margin: 0;
			padding: 20px;
		}

		h1 {
			color: #333;
			margin-bottom: 10px;
		}

		.controls {
			margin-bottom: 20px;
			display: flex;
			gap: 10px;
			align-items: center;
		}

		select,
		button {
			padding: 8px 12px;
			font-size: 16px;
			border-radius: 4px;
			border: 1px solid #ccc;
		}

		button {
			background-color: #4CAF50;
			color: white;
			border: none;
			cursor: pointer;
			transition: background-color 0.3s;
		}

		button:hover {
			background-color: #45a049;
		}

		.game-info {
			display: flex;
			justify-content: space-between;
			width: 300px;
			margin-bottom: 10px;
			font-size: 18px;
		}

		.minesweeper {
			display: grid;
			grid-template-columns: repeat(var(--cols), 30px);
			grid-template-rows: repeat(var(--rows), 30px);
			gap: 2px;
			background-color: #999;
			padding: 5px;
			border-radius: 5px;
			box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
		}

		.cell {
			width: 30px;
			height: 30px;
			background-color: #ccc;
			display: flex;
			justify-content: center;
			align-items: center;
			font-weight: bold;
			cursor: pointer;
			user-select: none;
			border: 2px outset #eee;
		}

		.cell.revealed {
			background-color: #e0e0e0;
			border: 1px solid #999;
		}

		.cell.mine {
			background-color: #ffcccc;
		}

		.cell.flagged {
			background-color: #ffeb3b;
		}

		.cell:hover:not(.revealed):not(.flagged) {
			background-color: #ddd;
		}

		.color-1 {
			color: blue;
		}

		.color-2 {
			color: green;
		}

		.color-3 {
			color: red;
		}

		.color-4 {
			color: darkblue;
		}

		.color-5 {
			color: brown;
		}

		.color-6 {
			color: teal;
		}

		.color-7 {
			color: black;
		}

		.color-8 {
			color: gray;
		}

		.game-over {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.7);
			display: flex;
			justify-content: center;
			align-items: center;
			flex-direction: column;
			color: white;
			font-size: 36px;
			z-index: 100;
			display: none;
		}

		.game-over button {
			margin-top: 20px;
			font-size: 24px;
			padding: 10px 20px;
		}
	</style>
</head>

<body>
	<h1>æ‰«é›·æ¸¸æˆ</h1>

	<div class="controls">
		<select id="difficulty">
			<option value="easy">ç®€å• (9Ã—9, 10é›·)</option>
			<option value="medium">ä¸­ç­‰ (16Ã—16, 40é›·)</option>
			<option value="hard">å›°éš¾ (30Ã—16, 99é›·)</option>
		</select>
		<button id="new-game">æ–°æ¸¸æˆ</button>
	</div>

	<div class="game-info">
		<div>å‰©ä½™é›·æ•°: <span id="mines-left">10</span></div>
		<div>æ—¶é—´: <span id="time">0</span>ç§’</div>
	</div>

	<div class="minesweeper" id="game-board"></div>

	<div class="game-over" id="game-over">
		<div id="game-result"></div>
		<button id="play-again">å†ç©ä¸€æ¬¡</button>
	</div>

	<script>
		// æ¸¸æˆé…ç½®
		const config = {
			easy: { rows: 9, cols: 9, mines: 10 },
			medium: { rows: 16, cols: 16, mines: 40 },
			hard: { rows: 16, cols: 30, mines: 99 }
		};

		// æ¸¸æˆçŠ¶æ€
		let gameState = {
			board: [],
			revealed: [],
			flagged: [],
			mines: 0,
			gameOver: false,
			firstClick: true,
			timer: null,
			seconds: 0
		};

		// DOM å…ƒç´ 
		const gameBoard = document.getElementById('game-board');
		const minesLeftDisplay = document.getElementById('mines-left');
		const timeDisplay = document.getElementById('time');
		const difficultySelect = document.getElementById('difficulty');
		const newGameBtn = document.getElementById('new-game');
		const gameOverScreen = document.getElementById('game-over');
		const gameResult = document.getElementById('game-result');
		const playAgainBtn = document.getElementById('play-again');

		// åˆå§‹åŒ–æ¸¸æˆ
		function initGame(difficulty = 'easy') {
			clearInterval(gameState.timer);

			const { rows, cols, mines } = config[difficulty];
			gameState = {
				board: Array(rows).fill().map(() => Array(cols).fill(0)),
				revealed: Array(rows).fill().map(() => Array(cols).fill(false)),
				flagged: Array(rows).fill().map(() => Array(cols).fill(false)),
				mines,
				gameOver: false,
				firstClick: true,
				timer: null,
				seconds: 0
			};

			// è®¾ç½®CSSå˜é‡
			gameBoard.style.setProperty('--rows', rows);
			gameBoard.style.setProperty('--cols', cols);

			// æ›´æ–°æ˜¾ç¤º
			minesLeftDisplay.textContent = mines;
			timeDisplay.textContent = '0';

			// åˆ›å»ºæ¸¸æˆæ¿
			renderBoard();

			// éšè—æ¸¸æˆç»“æŸå±å¹•
			gameOverScreen.style.display = 'none';
		}

		// æ¸²æŸ“æ¸¸æˆæ¿
		function renderBoard() {
			gameBoard.innerHTML = '';
			const { rows, cols } = getCurrentConfig();

			for (let y = 0; y < rows; y++) {
				for (let x = 0; x < cols; x++) {
					const cell = document.createElement('div');
					cell.className = 'cell';
					cell.dataset.x = x;
					cell.dataset.y = y;

					if (gameState.revealed[y][x]) {
						cell.classList.add('revealed');
						if (gameState.board[y][x] === -1) {
							cell.classList.add('mine');
							cell.textContent = 'ğŸ’£';
						} else if (gameState.board[y][x] > 0) {
							cell.textContent = gameState.board[y][x];
							cell.classList.add(`color-${gameState.board[y][x]}`);
						}
					} else if (gameState.flagged[y][x]) {
						cell.classList.add('flagged');
						cell.textContent = 'ğŸš©';
					}

					cell.addEventListener('click', () => handleCellClick(x, y));
					cell.addEventListener('contextmenu', (e) => {
						e.preventDefault();
						handleRightClick(x, y);
					});

					gameBoard.appendChild(cell);
				}
			}
		}

		// å¤„ç†å•å…ƒæ ¼ç‚¹å‡»
		function handleCellClick(x, y) {
			if (gameState.gameOver || gameState.flagged[y][x]) return;

			if (gameState.firstClick) {
				placeMines(x, y);
				gameState.firstClick = false;
				startTimer();
			}

			if (gameState.board[y][x] === -1) {
				// ç‚¹åˆ°åœ°é›·
				revealAllMines();
				gameOver(false);
				return;
			}

			revealCell(x, y);
			checkWin();
		}

		// å¤„ç†å³é”®ç‚¹å‡» (æ’æ——)
		function handleRightClick(x, y) {
			if (gameState.gameOver || gameState.revealed[y][x]) return;

			gameState.flagged[y][x] = !gameState.flagged[y][x];

			// æ›´æ–°å‰©ä½™é›·æ•°æ˜¾ç¤º
			const flaggedCount = gameState.flagged.flat().filter(Boolean).length;
			minesLeftDisplay.textContent = gameState.mines - flaggedCount;

			renderBoard();
		}

		// æ”¾ç½®åœ°é›·
		function placeMines(firstX, firstY) {
			const { rows, cols, mines } = getCurrentConfig();
			let minesPlaced = 0;

			// ç¡®ä¿ç¬¬ä¸€æ¬¡ç‚¹å‡»çš„ä½ç½®å‘¨å›´æ²¡æœ‰åœ°é›·
			const safeZone = getAdjacentCells(firstX, firstY);
			safeZone.push({ x: firstX, y: firstY });

			while (minesPlaced < mines) {
				const x = Math.floor(Math.random() * cols);
				const y = Math.floor(Math.random() * rows);

				// æ£€æŸ¥æ˜¯å¦åœ¨å®‰å…¨åŒºåŸŸæˆ–å·²ç»æœ‰åœ°é›·
				const isInSafeZone = safeZone.some(cell => cell.x === x && cell.y === y);
				if (!isInSafeZone && gameState.board[y][x] !== -1) {
					gameState.board[y][x] = -1;
					minesPlaced++;

					// æ›´æ–°å‘¨å›´å•å…ƒæ ¼çš„æ•°å­—
					for (const neighbor of getAdjacentCells(x, y)) {
						if (gameState.board[neighbor.y][neighbor.x] !== -1) {
							gameState.board[neighbor.y][neighbor.x]++;
						}
					}
				}
			}
		}

		// æ­ç¤ºå•å…ƒæ ¼
		function revealCell(x, y) {
			if (x < 0 || x >= gameState.board[0].length ||
				y < 0 || y >= gameState.board.length ||
				gameState.revealed[y][x] || gameState.flagged[y][x]) {
				return;
			}

			gameState.revealed[y][x] = true;

			// å¦‚æœæ˜¯ç©ºç™½å•å…ƒæ ¼ï¼Œé€’å½’æ­ç¤ºå‘¨å›´çš„å•å…ƒæ ¼
			if (gameState.board[y][x] === 0) {
				for (const neighbor of getAdjacentCells(x, y)) {
					revealCell(neighbor.x, neighbor.y);
				}
			}

			renderBoard();
		}

		// è·å–ç›¸é‚»å•å…ƒæ ¼
		function getAdjacentCells(x, y) {
			const { rows, cols } = getCurrentConfig();
			const cells = [];

			for (let dy = -1; dy <= 1; dy++) {
				for (let dx = -1; dx <= 1; dx++) {
					if (dx === 0 && dy === 0) continue;

					const nx = x + dx;
					const ny = y + dy;

					if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
						cells.push({ x: nx, y: ny });
					}
				}
			}

			return cells;
		}

		// æ­ç¤ºæ‰€æœ‰åœ°é›·
		function revealAllMines() {
			const { rows, cols } = getCurrentConfig();

			for (let y = 0; y < rows; y++) {
				for (let x = 0; x < cols; x++) {
					if (gameState.board[y][x] === -1) {
						gameState.revealed[y][x] = true;
					}
				}
			}

			renderBoard();
		}

		// å¼€å§‹è®¡æ—¶å™¨
		function startTimer() {
			clearInterval(gameState.timer);
			gameState.seconds = 0;
			timeDisplay.textContent = '0';

			gameState.timer = setInterval(() => {
				gameState.seconds++;
				timeDisplay.textContent = gameState.seconds;
			}, 1000);
		}

		// æ£€æŸ¥æ˜¯å¦è·èƒœ
		function checkWin() {
			const { rows, cols } = getCurrentConfig();
			let allNonMinesRevealed = true;

			for (let y = 0; y < rows; y++) {
				for (let x = 0; x < cols; x++) {
					if (gameState.board[y][x] !== -1 && !gameState.revealed[y][x]) {
						allNonMinesRevealed = false;
						break;
					}
				}
				if (!allNonMinesRevealed) break;
			}

			if (allNonMinesRevealed) {
				gameOver(true);
			}
		}

		// æ¸¸æˆç»“æŸ
		function gameOver(isWin) {
			gameState.gameOver = true;
			clearInterval(gameState.timer);

			if (isWin) {
				// æ ‡è®°æ‰€æœ‰åœ°é›·
				const { rows, cols } = getCurrentConfig();
				for (let y = 0; y < rows; y++) {
					for (let x = 0; x < cols; x++) {
						if (gameState.board[y][x] === -1) {
							gameState.flagged[y][x] = true;
						}
					}
				}
				renderBoard();
			}

			gameResult.textContent = isWin ? 'æ­å–œä½ èµ¢äº†!' : 'æ¸¸æˆç»“æŸ!';
			gameOverScreen.style.display = 'flex';
		}

		// è·å–å½“å‰é…ç½®
		function getCurrentConfig() {
			return config[difficultySelect.value];
		}

		// äº‹ä»¶ç›‘å¬å™¨
		newGameBtn.addEventListener('click', () => initGame(difficultySelect.value));
		playAgainBtn.addEventListener('click', () => initGame(difficultySelect.value));

		// åˆå§‹åŒ–æ¸¸æˆ
		initGame();
	</script>
</body>

</html>