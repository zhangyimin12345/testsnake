<!DOCTYPE html>
<!-- saved from url=(0028)http://127.0.0.1:8000/elsfk/ -->
<html lang="zh"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="icon" href="http://127.0.0.1:8000/static/favicon.ico" type="image/x-icon">
	<title>俄罗斯方块</title>
	<style>
		body {
			font-family: Arial, sans-serif;
			display: flex;
			flex-direction: column;
			align-items: center;
			background-color: #f0f0f0;
			margin: 0;
			padding: 20px;
		}

		h1 {
			color: #333;
			margin-bottom: 10px;
		}

		.game-container {
			display: flex;
			gap: 20px;
			margin-top: 20px;
		}

		#game-board {
			border: 2px solid #333;
			background-color: #111;
		}

		.side-panel {
			display: flex;
			flex-direction: column;
			gap: 20px;
			width: 150px;
		}

		.next-piece {
			border: 2px solid #333;
			background-color: #111;
		}

		.info-panel {
			background-color: #222;
			color: white;
			padding: 10px;
			border-radius: 5px;
		}

		.controls {
			margin-top: 20px;
			text-align: center;
		}

		button {
			padding: 10px 15px;
			background-color: #4CAF50;
			color: white;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 16px;
			margin: 0 5px;
		}

		button:hover {
			background-color: #45a049;
		}

		.game-over {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background-color: rgba(0, 0, 0, 0.8);
			color: white;
			padding: 20px;
			border-radius: 10px;
			text-align: center;
			display: none;
		}
	</style>
</head>

<body>
	<h1>俄罗斯方块</h1>

	<div class="game-container">
		<canvas id="game-board" width="300" height="600"></canvas>

		<div class="side-panel">
			<div class="info-panel">
				<h3>分数: <span id="score">0</span></h3>
				<h3>等级: <span id="level">1</span></h3>
				<h3>行数: <span id="lines">0</span></h3>
			</div>

			<div class="next-piece-container">
				<h3>下一个:</h3>
				<canvas id="next-piece" width="150" height="150"></canvas>
			</div>
		</div>
	</div>

	<div class="controls">
		<button id="start-btn">开始游戏</button>
		<button id="pause-btn">暂停</button>
	</div>

	<div class="game-over" id="game-over">
		<h2>游戏结束!</h2>
		<p>最终分数: <span id="final-score">0</span></p>
		<button id="restart-btn">重新开始</button>
	</div>

	<script>
		// 游戏常量
		const COLS = 10;
		const ROWS = 20;
		const BLOCK_SIZE = 30;
		const NEXT_BLOCK_SIZE = 25;

		// 方块形状定义
		const SHAPES = [
			[],
			[[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], // I
			[[2, 0, 0], [2, 2, 2], [0, 0, 0]],                          // J
			[[0, 0, 3], [3, 3, 3], [0, 0, 0]],                          // L
			[[4, 4], [4, 4]],                                           // O
			[[0, 5, 5], [5, 5, 0], [0, 0, 0]],                          // S
			[[0, 6, 0], [6, 6, 6], [0, 0, 0]],                          // T
			[[7, 7, 0], [0, 7, 7], [0, 0, 0]]                           // Z
		];

		// 方块颜色
		const COLORS = [
			'#000000', // 空
			'#00FFFF', // I - 青色
			'#0000FF', // J - 蓝色
			'#FF7F00', // L - 橙色
			'#FFFF00', // O - 黄色
			'#00FF00', // S - 绿色
			'#800080', // T - 紫色
			'#FF0000'  // Z - 红色
		];

		// 游戏变量
		let canvas, ctx;
		let nextCanvas, nextCtx;
		let board = [];
		let currentPiece, nextPiece;
		let score = 0;
		let level = 1;
		let lines = 0;
		let gameOver = false;
		let isPaused = false;
		let dropInterval;
		let dropStart;

		// 初始化游戏
		function init() {
			canvas = document.getElementById('game-board');
			ctx = canvas.getContext('2d');

			nextCanvas = document.getElementById('next-piece');
			nextCtx = nextCanvas.getContext('2d');

			// 初始化游戏板
			createBoard();

			// 生成第一个方块和下一个方块
			nextPiece = generatePiece();
			newPiece();

			// 事件监听
			document.addEventListener('keydown', control);
			document.getElementById('start-btn').addEventListener('click', startGame);
			document.getElementById('pause-btn').addEventListener('click', togglePause);
			document.getElementById('restart-btn').addEventListener('click', resetGame);
		}

		// 创建游戏板
		function createBoard() {
			board = [];
			for (let r = 0; r < ROWS; r++) {
				board[r] = [];
				for (let c = 0; c < COLS; c++) {
					board[r][c] = 0;
				}
			}
		}

		// 生成随机方块
		function generatePiece() {
			const randomIndex = Math.floor(Math.random() * 7) + 1; // 1-7
			const shape = SHAPES[randomIndex];
			const piece = {
				shape: shape,
				color: COLORS[randomIndex],
				x: Math.floor(COLS / 2) - Math.floor(shape[0].length / 2),
				y: 0
			};
			return piece;
		}

		// 创建新方块
		function newPiece() {
			currentPiece = nextPiece;
			nextPiece = generatePiece();
			drawNextPiece();

			// 检查游戏是否结束
			if (collision(0, 0)) {
				gameOver = true;
				clearInterval(dropInterval);
				showGameOver();
			}
		}

		// 绘制游戏板
		function drawBoard() {
			ctx.clearRect(0, 0, canvas.width, canvas.height);

			for (let r = 0; r < ROWS; r++) {
				for (let c = 0; c < COLS; c++) {
					if (board[r][c]) {
						drawBlock(c, r, board[r][c]);
					}
				}
			}

			// 绘制当前方块
			if (currentPiece) {
				for (let r = 0; r < currentPiece.shape.length; r++) {
					for (let c = 0; c < currentPiece.shape[r].length; c++) {
						if (currentPiece.shape[r][c]) {
							drawBlock(currentPiece.x + c, currentPiece.y + r, currentPiece.color);
						}
					}
				}
			}
		}

		// 绘制单个方块
		function drawBlock(x, y, color) {
			ctx.fillStyle = color;
			ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
			ctx.strokeStyle = '#000';
			ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
		}

		// 绘制下一个方块
		function drawNextPiece() {
			nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);

			if (nextPiece) {
				const offsetX = (nextCanvas.width - nextPiece.shape[0].length * NEXT_BLOCK_SIZE) / 2;
				const offsetY = (nextCanvas.height - nextPiece.shape.length * NEXT_BLOCK_SIZE) / 2;

				for (let r = 0; r < nextPiece.shape.length; r++) {
					for (let c = 0; c < nextPiece.shape[r].length; c++) {
						if (nextPiece.shape[r][c]) {
							nextCtx.fillStyle = nextPiece.color;
							nextCtx.fillRect(
								offsetX + c * NEXT_BLOCK_SIZE,
								offsetY + r * NEXT_BLOCK_SIZE,
								NEXT_BLOCK_SIZE,
								NEXT_BLOCK_SIZE
							);
							nextCtx.strokeStyle = '#000';
							nextCtx.strokeRect(
								offsetX + c * NEXT_BLOCK_SIZE,
								offsetY + r * NEXT_BLOCK_SIZE,
								NEXT_BLOCK_SIZE,
								NEXT_BLOCK_SIZE
							);
						}
					}
				}
			}
		}

		// 检测碰撞
		function collision(offsetX, offsetY) {
			for (let r = 0; r < currentPiece.shape.length; r++) {
				for (let c = 0; c < currentPiece.shape[r].length; c++) {
					if (!currentPiece.shape[r][c]) continue;

					const newX = currentPiece.x + c + offsetX;
					const newY = currentPiece.y + r + offsetY;

					if (newX < 0 || newX >= COLS || newY >= ROWS) {
						return true;
					}

					if (newY < 0) {
						continue;
					}

					if (board[newY][newX]) {
						return true;
					}
				}
			}
			return false;
		}

		// 锁定方块到游戏板
		function lock() {
			for (let r = 0; r < currentPiece.shape.length; r++) {
				for (let c = 0; c < currentPiece.shape[r].length; c++) {
					if (!currentPiece.shape[r][c]) continue;

					// 游戏结束检查
					if (currentPiece.y + r < 0) {
						gameOver = true;
						showGameOver();
						return;
					}

					board[currentPiece.y + r][currentPiece.x + c] = currentPiece.color;
				}
			}

			// 检查是否有完整的行
			checkRows();

			// 生成新方块
			newPiece();
		}

		// 检查并清除完整的行
		function checkRows() {
			let rowsCleared = 0;

			for (let r = ROWS - 1; r >= 0; r--) {
				let isRowFull = true;

				for (let c = 0; c < COLS; c++) {
					if (board[r][c] === 0) {
						isRowFull = false;
						break;
					}
				}

				if (isRowFull) {
					// 移除该行并增加上面的行
					for (let y = r; y > 0; y--) {
						for (let c = 0; c < COLS; c++) {
							board[y][c] = board[y - 1][c];
						}
					}

					// 清空最上面一行
					for (let c = 0; c < COLS; c++) {
						board[0][c] = 0;
					}

					rowsCleared++;
					r++; // 再次检查当前行，因为上面的行已经下移
				}
			}

			if (rowsCleared > 0) {
				// 更新分数
				updateScore(rowsCleared);
			}
		}

		// 更新分数
		function updateScore(rowsCleared) {
			const points = [0, 40, 100, 300, 1200]; // 0, 1, 2, 3, 4行的分数
			score += points[rowsCleared] * level;
			lines += rowsCleared;

			// 每清除10行升一级
			level = Math.floor(lines / 10) + 1;

			// 更新显示
			document.getElementById('score').textContent = score;
			document.getElementById('level').textContent = level;
			document.getElementById('lines').textContent = lines;

			// 加快下落速度
			if (dropInterval) {
				clearInterval(dropInterval);
				dropInterval = setInterval(drop, 1000 / level);
			}
		}

		// 方块下落
		function drop() {
			if (!collision(0, 1)) {
				currentPiece.y++;
				drawBoard();
			} else {
				lock();
				if (!gameOver) {
					drawBoard();
				}
			}
		}

		// 旋转方块
		function rotate() {
			const originalShape = currentPiece.shape;

			// 转置矩阵
			const rows = currentPiece.shape.length;
			const cols = currentPiece.shape[0].length;
			const newShape = [];

			for (let c = 0; c < cols; c++) {
				newShape[c] = [];
				for (let r = rows - 1; r >= 0; r--) {
					newShape[c][rows - 1 - r] = currentPiece.shape[r][c];
				}
			}

			currentPiece.shape = newShape;

			// 如果旋转后发生碰撞，则恢复原状
			if (collision(0, 0)) {
				currentPiece.shape = originalShape;
			}

			drawBoard();
		}

		// 键盘控制
		function control(e) {
			if (gameOver || isPaused) return;

			switch (e.keyCode) {
				case 37: // 左箭头
					if (!collision(-1, 0)) {
						currentPiece.x--;
						drawBoard();
					}
					break;
				case 39: // 右箭头
					if (!collision(1, 0)) {
						currentPiece.x++;
						drawBoard();
					}
					break;
				case 40: // 下箭头
					if (!collision(0, 1)) {
						currentPiece.y++;
						drawBoard();
					}
					break;
				case 38: // 上箭头 - 旋转
					rotate();
					break;
				case 32: // 空格 - 硬降
					hardDrop();
					break;
			}
		}

		// 硬降 - 直接落到底部
		function hardDrop() {
			while (!collision(0, 1)) {
				currentPiece.y++;
			}
			lock();
			drawBoard();
		}

		// 开始游戏
		function startGame() {
			if (dropInterval) {
				clearInterval(dropInterval);
			}

			resetGame();

			dropInterval = setInterval(drop, 1000 / level);
			dropStart = Date.now();
			gameOver = false;
			isPaused = false;

			document.getElementById('pause-btn').textContent = '暂停';
		}

		// 暂停/继续游戏
		function togglePause() {
			if (gameOver) return;

			isPaused = !isPaused;

			if (isPaused) {
				clearInterval(dropInterval);
				document.getElementById('pause-btn').textContent = '继续';
			} else {
				dropInterval = setInterval(drop, 1000 / level);
				document.getElementById('pause-btn').textContent = '暂停';
			}
		}

		// 重置游戏
		function resetGame() {
			clearInterval(dropInterval);

			createBoard();
			score = 0;
			level = 1;
			lines = 0;

			document.getElementById('score').textContent = score;
			document.getElementById('level').textContent = level;
			document.getElementById('lines').textContent = lines;

			nextPiece = generatePiece();
			newPiece();
			drawBoard();
			drawNextPiece();

			gameOver = false;
			isPaused = false;

			document.getElementById('game-over').style.display = 'none';
			document.getElementById('pause-btn').textContent = '暂停';
		}

		// 显示游戏结束
		function showGameOver() {
			document.getElementById('final-score').textContent = score;
			document.getElementById('game-over').style.display = 'block';
		}

		// 初始化游戏
		window.onload = init;
	</script>


</body></html>